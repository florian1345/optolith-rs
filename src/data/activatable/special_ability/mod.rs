use crate::data::{Localization, Translatable, Translations};
use crate::data::activatable::{
    APValue,
    SelectOptions,
    SkillApplications,
    SkillUses
};
use crate::data::errata::Errata;
use crate::data::prerequisite::{DisplayOption, GeneralListOrByLevelPrerequisite};
use crate::data::simple::SimpleEntity;
use crate::data::src::SourceRefs;
use crate::id::{Category, CategoryProvider, Id, Identifiable};

use serde::{Deserialize, Serialize};

use std::marker::PhantomData;

pub mod ceremonial_item;
pub mod combat;
pub mod enchantment;
pub mod gift;
pub mod non_profane;
pub mod ordinary;
pub mod skill;
pub mod trade_secret;
pub mod tradition;

#[derive(Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SpecialAbilityLocalization {

    /// The name of the entry.
    pub name: String,

    /// The name of the entry shown in Wiki. Only use when `name` needs to be
    /// different from full name.
    #[serde(rename = "nameInLibrary")]
    pub name_in_library: Option<String>,

    /// A string that is used as a placeholder text for an input field.
    pub input: Option<String>,

    /// The rule text. Markdown is available.
    pub rules: String,

    /// The penalty the special ability gives when used.
    pub penalty: Option<String>,

    /// Use if text cannot be generated by the app. Markdown is available.
    pub prerequisites: Option<String>,

    /// Prepends the provided string to the main prerequisites string. No
    /// effect if `prerequisites` field is used in l10n file. Markdown is
    /// available.
    #[serde(rename = "prerequisitesStart")]
    pub prerequisites_start: Option<String>,

    /// Appends the provided string to the main prerequisites string. No effect
    /// if `prerequisites` field is used in l10n table. Markdown is available.
    #[serde(rename = "prerequisitesEnd")]
    pub prerequisites_end: Option<String>,

    /// The AP value. Only use this if the text provides different information
    /// than `X adventure points`, e.g. for Special Ability Property Knowledge
    /// it is \"10 adventure points for the first *Property Knowledge*, 20
    /// adventure points for the second, 40 adventure points for the third\".
    /// Markdown is available.
    #[serde(rename = "apValue")]
    pub ap_value: Option<String>,

    /// An addition to the default AP value schema. Only use this if the text
    /// provides information appended to `X adventure points` and if `apValue`
    /// is not used. Markdown is available.
    #[serde(rename = "apValueAppend")]
    pub ap_value_append: Option<String>,
    pub errata: Option<Errata>
}

impl Localization for SpecialAbilityLocalization {
    fn name(&self) -> &str {
        &self.name
    }
}

/// A normal special ability localization with a field `effect` instead of
/// `rules`.
#[derive(Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct EffectSpecialAbilityLocalization {
    
    /// The name of the entry.
    pub name: String,

    /// The name of the entry shown in Wiki. Only use when `name` needs to be
    /// different from full name.
    #[serde(rename = "nameInWiki")]
    pub name_in_wiki: Option<String>,

    /// A string that is used as a placeholder text for an input field.
    pub input: Option<String>,

    /// The effect description. Markdown is available.
    pub effect: String,

    /// Use if text cannot be generated by the app. Markdown is available.
    pub prerequisites: Option<String>,

    /// Prepends the provided string to the main prerequisites string. No
    /// effect if `prerequisites` field is used in l10n file. Markdown is
    /// available.
    #[serde(rename = "prerequisitesStart")]
    pub prerequisites_start: Option<String>,

    /// Appends the provided string to the main prerequisites string. No effect
    /// if `prerequisites` field is used in l10n table. Markdown is available.
    #[serde(rename = "prerequisitesEnd")]
    pub prerequisites_end: Option<String>,

    /// The AP value. Only use this if the text provides different information
    /// than `X adventure points`, e.g. for Special Ability Property Knowledge
    /// it is \"10 adventure points for the first *Property Knowledge*, 20
    /// adventure points for the second, 40 adventure points for the third\".
    /// Markdown is available.
    #[serde(rename = "apValue")]
    pub ap_value: Option<String>,

    /// An addition to the default AP value schema. Only use this if the text
    /// provides information appended to `X adventure points` and if `apValue`
    /// is not used. Markdown is available.
    #[serde(rename = "apValueAppend")]
    pub ap_value_append: Option<String>,
    pub errata: Option<Errata>
}

impl Localization for EffectSpecialAbilityLocalization {
    fn name(&self) -> &str {
        &self.name
    }
}

#[derive(Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub enum RestrictOptionsType {
    Element
}

#[derive(Deserialize, Serialize)]
#[serde(untagged)]
#[serde(deny_unknown_fields)]
pub enum RestrictOption {
    Direct(u32),

    /// Specify, if only one specific select option or one of a set of select
    /// options is allowed for the referenced advanced special ability.
    ByType {
        #[serde(rename = "type")]
        ro_type: RestrictOptionsType,
        value: u32
    },
}

#[derive(Deserialize, Serialize)]
#[serde(untagged)]
#[serde(deny_unknown_fields)]
pub enum RestrictOptions {
    Single(RestrictOption),
    Multiple(Vec<RestrictOption>)
}

#[derive(Deserialize, Serialize)]
#[serde(tag = "type", content = "value")]
#[serde(deny_unknown_fields)]
pub enum ExternalEntry {
    MagicalTradition(u32)
}

#[derive(Deserialize, Serialize)]
#[serde(tag = "type", content = "value")]
#[serde(deny_unknown_fields)]
pub enum FromOption {
    Patron(u32)
}

#[derive(Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct Mapping {
    #[serde(rename = "fromOption")]
    from_option: FromOption,
    #[serde(rename = "toAdvanced")]
    to_advanced: u32
}

#[derive(Deserialize, Serialize)]
#[serde(tag = "type")]
#[serde(deny_unknown_fields)]
pub enum ComplexAdvancedSpecialAbility {
    RestrictOptions {
        id: u32,
        option: RestrictOptions
    },
    OneOf {
        options: Vec<u32>,
        #[serde(rename = "isSelectionRequiredOnPurchase")]
        is_selection_required_on_purchase: bool,
        #[serde(rename = "displayOption")]
        display_option: Option<DisplayOption>
    },
    DeriveFromExternalOption {
        #[serde(rename = "externalEntry")]
        external_entry: ExternalEntry,
        mappings: Vec<Mapping>
    }
}

#[derive(Deserialize, Serialize)]
#[serde(untagged)]
#[serde(deny_unknown_fields)]
pub enum AdvancedSpecialAbility {
    Simple(u32),
    // TODO figure out how to model this properly
    SimpleWithOptions {
        id: u32,
        option: RestrictOptions
    },
    Complex(ComplexAdvancedSpecialAbility)
}

/// The Advanced Special Abilities for the respective Style Special Ability.
/// Sometimes, only a specific select option or a set of select options of an
/// entry is allowed, which can be modelled by the option property. It can also
/// be that you can choose from a set of special abilities, but then you cannot
/// specify an option.
pub type AdvancedSpecialAbilities = [AdvancedSpecialAbility; 3];

#[derive(Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SimpleSpecialAbility<C: CategoryProvider, L: Localization> {
    pub id: u32,
    pub levels: Option<u32>,
    pub max: Option<u32>,
    #[serde(rename = "selectOptions")]
    pub select_options: Option<SelectOptions>,
    pub prerequisites: Option<GeneralListOrByLevelPrerequisite>,
    #[serde(rename = "apValue")]
    pub ap_value: Option<APValue>,
    pub src: SourceRefs,
    pub translations: Translations<L>,
    #[serde(skip)]
    category: PhantomData<C>
}

impl<C, L> Translatable for SimpleSpecialAbility<C, L>
where
    C: CategoryProvider,
    L: Localization
{
    type Localization = L;

    fn translations(&self) -> &Translations<L> {
        &self.translations
    }
}

impl<C, L> Identifiable for SimpleSpecialAbility<C, L>
where
    C: CategoryProvider,
    L: Localization
{
    fn id(&self) -> Id {
        Id::new(C::CATEGORY, self.id)
    }
}

#[derive(Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SkillInfluencingSpecialAbility<C, L>
where
    C: CategoryProvider,
    L: Localization
{
    pub id: u32,
    pub levels: Option<u32>,
    pub max: Option<u32>,

    /// Registers new applications, which get enabled once this entry is
    /// activated. It specifies an entry-unique identifier and the skill it
    /// belongs to. A translation can be left out if its name equals the name
    /// of the origin entry.
    #[serde(rename = "skillApplications")]
    pub skill_applications: Option<SkillApplications>,

    /// Registers uses, which get enabled once this entry is activated. It
    /// specifies an entry-unique identifier and the skill it belongs to. A
    /// translation can be left out if its name equals the name of the origin
    /// entry.
    #[serde(rename = "skillUses")]
    pub skill_uses: Option<SkillUses>,
    #[serde(rename = "selectOptions")]
    pub select_options: Option<SelectOptions>,
    pub prerequisites: Option<GeneralListOrByLevelPrerequisite>,
    #[serde(rename = "apValue")]
    pub ap_value: Option<APValue>,
    pub src: SourceRefs,
    pub translations: Translations<L>,
    #[serde(skip)]
    category: PhantomData<C>
}

impl<C, L> Translatable for SkillInfluencingSpecialAbility<C, L>
where
    C: CategoryProvider,
    L: Localization
{
    type Localization = L;

    fn translations(&self) -> &Translations<L> {
        &self.translations
    }
}

impl<C, L> Identifiable for SkillInfluencingSpecialAbility<C, L>
where
    C: CategoryProvider,
    L: Localization
{
    fn id(&self) -> Id {
        Id::new(C::CATEGORY, self.id)
    }
}

#[derive(Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub enum SpecialAbilityType {
    GeneralSpecialAbility,
    FatePointSpecialAbility,
    CombatSpecialAbility,
    MagicalSpecialAbility,
    StaffEnchantment,
    FamiliarSpecialAbility,
    KarmaSpecialAbility,
    ProtectiveWardingCircleSpecialAbility,
    CombatStyleSpecialAbility,
    AdvancedCombatSpecialAbility,
    CommandSpecialAbility,
    MagicStyleSpecialAbility,
    AdvancedMagicalSpecialAbility,
    SpellSwordEnchantment,
    DaggerRitual,
    InstrumentEnchantment,
    AttireEnchantment,
    OrbEnchantment,
    WandEnchantment,
    BrawlingSpecialAbility,
    AncestorGlyph,
    CeremonialItemSpecialAbility,
    Sermon,
    LiturgicalStyleSpecialAbility,
    AdvancedKarmaSpecialAbility,
    Vision,
    MagicalTradition,
    BlessedTradition,
    PactGift,
    SikaryanDrainSpecialAbility,
    LycantropicGift,
    Talentstilsonderfertigkeit,
    AdvancedSkillSpecialAbility,
    ArcaneOrbEnchantment,
    CauldronEnchantment,
    FoolsHatEnchantment,
    ToyEnchantment,
    BowlEnchantment,
    FatePointSexSpecialAbility,
    SexSpecialAbility,
    WeaponEnchantment,
    SickleRitual,
    RingEnchantment,
    ChronicleEnchantment
}

#[derive(Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SpecialAbilityId {
    #[serde(rename = "type")]
    pub sa_type: SpecialAbilityType,
    pub value: u32
}

pub struct SpecialAbilityGroupCategory;

impl CategoryProvider for SpecialAbilityGroupCategory {
    const CATEGORY: Category = Category::SpecialAbilityGroups;
}

pub type SpecialAbilityGroup = SimpleEntity<SpecialAbilityGroupCategory>;
