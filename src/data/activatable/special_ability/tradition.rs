use crate::data::{Localization, Translatable, Translations};
use crate::data::activatable::{
    APValue,
    SelectOptions,
    SkillApplications,
    SkillUses
};
use crate::data::errata::Errata;
use crate::data::prerequisite::{
    ArcaneTraditionListPrerequisite,
    GeneralListOrByLevelPrerequisite,
    MagicalTraditionPrerequisite
};
use crate::data::simple::{
    SimpleEntity,
    SimpleLocalization,
    SimpleTranslations
};
use crate::data::skill::combat::CombatTechniqueId;
use crate::data::src::SourceRefs;
use crate::id::{Category, CategoryProvider, Id, Identifiable};

use serde::{Deserialize, Serialize};

use std::marker::PhantomData;

#[derive(Deserialize, Serialize)]
#[serde(tag = "type", content = "value")]
#[serde(deny_unknown_fields)]
pub enum FavoredCombatTechniques {
    All,
    AllMelee,
    AllUsedInHunting,
    List(Vec<CombatTechniqueId>)
}

#[derive(Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct FavoredSkillsSelection {
    pub amount: u32,
    pub options: Vec<u32>
}

#[derive(Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SpecialRuleLocalization {

    /// An optional label that is displayed and placed before the actual text.
    pub label: Option<String>,

    /// The text of a special rule.
    pub text: String
}

#[derive(Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct BlessedTraditionLocalization {

    /// The tradition's name.
    pub name: String,

    /// A shorter name of the tradition's name, used in liturgical chant
    /// descriptions.
    #[serde(rename = "nameShort")]
    pub name_short: Option<String>,

    /// The name of the entry shown in Wiki. Only use when `name` needs to be
    /// different from full name.
    #[serde(rename = "nameInWiki")]
    pub name_in_wiki: Option<String>,

    /// A string that is used as a placeholder text for an input field.
    pub input: Option<String>,

    /// The special rules of the tradition. They should be sorted like they are
    /// in the book.
    #[serde(rename = "specialRules")]
    pub special_rules: Option<Vec<SpecialRuleLocalization>>,

    /// Use if text cannot be generated by the app. Markdown is available.
    pub prerequisites: Option<String>,

    /// Prepends the provided string to the main prerequisites string. No
    /// effect if `prerequisites` field is used in l10n file. Markdown is
    /// available.
    #[serde(rename = "prerequisitesStart")]
    pub prerequisites_start: Option<String>,

    /// Appends the provided string to the main prerequisites string. No effect
    /// if `prerequisites` field is used in l10n table. Markdown is available.
    #[serde(rename = "prerequisitesEnd")]
    pub prerequisites_end: Option<String>,

    /// The AP value. Only use this if the text provides different information
    /// than `X adventure points`, e.g. for Special Ability Property Knowledge
    /// it is \"10 adventure points for the first *Property Knowledge*, 20
    /// adventure points for the second, 40 adventure points for the third\".
    /// Markdown is available.
    #[serde(rename = "apValue")]
    pub ap_value: Option<String>,

    /// An addition to the default AP value schema. Only use this if the text
    /// provides information appended to `X adventure points` and if `apValue`
    /// is not used. Markdown is available.
    #[serde(rename = "apValueAppend")]
    pub ap_value_append: Option<String>,
    pub errata: Option<Errata>
}

impl Localization for BlessedTraditionLocalization {
    fn name(&self) -> &str {
        &self.name
    }
}

#[derive(Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct BlessedTradition {
    pub id: u32,
    pub levels: Option<u32>,
    pub max: Option<u32>,
    
    /// Registers new applications, which get enabled once this entry is
    /// activated. It specifies an entry-unique identifier and the skill it
    /// belongs to. A translation can be left out if its name equals the name
    /// of the origin entry.
    #[serde(rename = "skillApplications")]
    pub skill_applications: Option<SkillApplications>,

    /// Registers uses, which get enabled once this entry is activated. It
    /// specifies an entry-unique identifier and the skill it belongs to. A
    /// translation can be left out if its name equals the name of the origin
    /// entry.
    #[serde(rename = "skillUses")]
    pub skill_uses: Option<SkillUses>,
    #[serde(rename = "selectOptions")]
    pub select_options: Option<SelectOptions>,

    /// The tradition's primary attribute.
    pub primary: u32,

    /// The tradition's aspects.
    pub aspects: Option<[u32; 2]>,

    /// If a tradition restricts the possible blessings, use this to define
    /// which blessings are not allowed.
    #[serde(rename = "restrictedBlessings")]
    pub restricted_blessings: Option<Vec<u32>>,

    /// A list of favored combat techniques.
    #[serde(rename = "favoredCombatTechniques")]
    pub favored_combat_techniques: Option<FavoredCombatTechniques>,

    /// A list of favored skills.
    #[serde(rename = "favoredSkills")]
    pub favored_skills: Vec<u32>,
    #[serde(rename = "favoredSkillsSelection")]
    pub favored_skills_selection: Option<FavoredSkillsSelection>,

    /// Is this a schamanistic tradition?
    #[serde(rename = "isShamanistic")]
    pub is_shamanistic: bool,

    /// The select option identifier of the disadvantage Principles that
    /// represent this tradition's code.
    #[serde(rename = "associatedPrinciplesId")]
    pub associated_principles_id: Option<u32>,
    #[serde(rename = "apValue")]
    pub ap_value: Option<APValue>,
    pub prerequisites: Option<GeneralListOrByLevelPrerequisite>,
    pub src: SourceRefs,
    pub translations: Translations<BlessedTraditionLocalization>
}

impl Identifiable for BlessedTradition {
    fn id(&self) -> Id {
        Id::new(Category::BlessedTraditions, self.id)
    }
}

impl Translatable for BlessedTradition {
    type Localization = BlessedTraditionLocalization;

    fn translations(&self) -> &Translations<BlessedTraditionLocalization> {
        &self.translations
    }
}

#[derive(Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct MagicalTraditionLocalization {
    pub name: String,

    /// The name used for the traditions list of arcane spellworks if it is
    /// different than the name of the special ability (`name`).
    #[serde(rename = "nameForArcaneSpellworks")]
    pub name_for_arcane_spellworks: Option<String>,

    /// The name of the entry shown in Wiki. Only use when `name` needs to be
    /// different from full name.
    #[serde(rename = "nameInWiki")]
    pub name_in_wiki: Option<String>,

    /// A string that is used as a placeholder text for an input field.
    pub input: Option<String>,

    /// The special rules of the tradition. They should be sorted like they are
    /// in the book.
    #[serde(rename = "specialRules")]
    pub special_rules: Vec<SpecialRuleLocalization>,

    /// Use if text cannot be generated by the app. Markdown is available.
    pub prerequisites: Option<String>,

    /// Prepends the provided string to the main prerequisites string. No
    /// effect if `prerequisites` field is used in l10n file. Markdown is
    /// available.
    #[serde(rename = "prerequisitesStart")]
    pub prerequisites_start: Option<String>,

    /// Appends the provided string to the main prerequisites string. No effect
    /// if `prerequisites` field is used in l10n table. Markdown is available.
    #[serde(rename = "prerequisitesEnd")]
    pub prerequisites_end: Option<String>,

    /// The AP value. Only use this if the text provides different information
    /// than `X adventure points`, e.g. for Special Ability Property Knowledge
    /// it is \"10 adventure points for the first *Property Knowledge*, 20
    /// adventure points for the second, 40 adventure points for the third\".
    /// Markdown is available.
    #[serde(rename = "apValue")]
    pub ap_value: Option<String>,

    /// An addition to the default AP value schema. Only use this if the text
    /// provides information appended to `X adventure points` and if `apValue`
    /// is not used. Markdown is available.
    #[serde(rename = "apValueAppend")]
    pub ap_value_append: Option<String>,
    pub errata: Option<Errata>
}

impl Localization for MagicalTraditionLocalization {
    fn name(&self) -> &str {
        &self.name
    }
}

#[derive(Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct MagicalTradition {
    pub id: u32,
    pub levels: Option<u32>,
    pub max: Option<u32>,
    #[serde(rename = "selectOptions")]
    pub select_options: Option<SelectOptions>,

    /// The tradition's primary attribute. Leave empty if the tradition does
    /// not have one.
    pub primary: Option<u32>,

    /// Typically, the value of the primary attribute (if one exists) is added
    /// onto the base of 20 AE to get the actual AE. But sometimes, only half
    /// the value is added.
    #[serde(rename = "useHalfPrimaryForAE")]
    pub use_half_primary_for_ae: Option<bool>,

    /// Can a member of the tradition learn cantrips?
    #[serde(rename = "canLearnCantrips")]
    pub can_learn_cantrips: bool,

    /// Can a member of the tradition learn spells?
    #[serde(rename = "canLearnSpells")]
    pub can_learn_spells: bool,

    /// Can a member of the tradition learn rituals?
    #[serde(rename = "canLearnRituals")]
    pub can_learn_rituals: bool,

    /// Can this magical tradition bind familiars?
    #[serde(rename = "canBindFamiliars")]
    pub can_bind_familiars: bool,

    /// Does the tradition allow learning more traditions or having learned a
    /// different tradition before learning this tradition?
    #[serde(rename = "allowMultipleTraditions")]
    pub allow_multiple_traditions: bool,

    /// Is the maximum AP you're able to spent on magical advantages and able
    /// to get by magical disadvantages different than the default of 50 AP?
    #[serde(rename = "alternativeDisAdvAPMax")]
    pub alternative_dis_adv_ap_max: Option<u32>,

    /// Are advantages/disadvantages required to not exclusively apply to
    /// arcane spellworks, but also to the tradition's magical actions or
    /// applications?
    #[serde(rename = "areDisAdvRequiredApplyToMagActionsOrApps")]
    pub are_dis_adv_required_apply_to_mag_actions_or_apps: bool,

    /// Is this a magical dilettante tradition?
    #[serde(rename = "isMagicalDilettante")]
    pub is_magical_dilettante: bool,

    /// If arcane spellworks from a different tradition count as arcane
    /// spellworks of this tradition, insert the different tradition's id here.
    #[serde(rename = "useArcaneSpellworksFromTradition")]
    pub use_arcane_spellworks_from_tradition: Option<u32>,

    // TODO influences?

    #[serde(rename = "apValue")]
    pub ap_value: Option<APValue>,
    pub prerequisites: Option<MagicalTraditionPrerequisite>,
    pub src: SourceRefs,
    pub translations: Translations<MagicalTraditionLocalization>
}

impl Identifiable for MagicalTradition {
    fn id(&self) -> Id {
        Id::new(Category::MagicalTraditions, self.id)
    }
}

impl Translatable for MagicalTradition {
    type Localization = MagicalTraditionLocalization;

    fn translations(&self) -> &Translations<MagicalTraditionLocalization> {
        &self.translations
    }
}

/// A schema that matches both the arcane bard and dancer traditions.
#[derive(Serialize, Deserialize)]
#[serde(deny_unknown_fields)]
pub struct ArcaneProfessionTradition<C: CategoryProvider> {
    pub id: u32,
    pub prerequisites: ArcaneTraditionListPrerequisite,
    pub translations: SimpleTranslations,
    #[serde(skip)]
    category: PhantomData<C>
}

impl<C: CategoryProvider> Identifiable for ArcaneProfessionTradition<C> {
    fn id(&self) -> Id {
        Id::new(C::CATEGORY, self.id)
    }
}

impl<C> Translatable for ArcaneProfessionTradition<C>
where
    C: CategoryProvider
{
    type Localization = SimpleLocalization;

    fn translations(&self) -> &Translations<SimpleLocalization> {
        &self.translations
    }
}

pub struct ArcaneBardTraditionCategory;

impl CategoryProvider for ArcaneBardTraditionCategory {
    const CATEGORY: Category = Category::ArcaneBardTraditions;
}

pub type ArcaneBardTradition =
    ArcaneProfessionTradition<ArcaneBardTraditionCategory>;

pub struct ArcaneDancerTraditionCategory;

impl CategoryProvider for ArcaneDancerTraditionCategory {
    const CATEGORY: Category = Category::ArcaneDancerTraditions;
}

pub type ArcaneDancerTradition =
    ArcaneProfessionTradition<ArcaneDancerTraditionCategory>;

pub struct MagicalTraditionPlaceholderCategory;

impl CategoryProvider for MagicalTraditionPlaceholderCategory {
    const CATEGORY: Category = Category::MagicalTraditionPlaceholders;
}

pub type MagicalTraditionPlaceholder =
    SimpleEntity<MagicalTraditionPlaceholderCategory>;
