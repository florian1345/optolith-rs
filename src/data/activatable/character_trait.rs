use crate::data::{Localization, Translatable, Translations};
use crate::data::activatable::{APValue, SelectOptions};
use crate::data::prerequisite::TraitlListOrByLevelPrerequisite;
use crate::data::src::SourceRefs;
use crate::id::{Category, Id, Identifiable};

use serde::{Deserialize, Serialize};

use serde_repr::{Deserialize_repr, Serialize_repr};

#[derive(Deserialize_repr, Serialize_repr)]
#[repr(u32)]
pub enum TraitGroup {
    Profane = 1,
    Arcane = 2,
    Karmal = 3
}

#[derive(Deserialize, Serialize)]
pub struct TraitLocalization {

    /// The name of the entry.
    pub name: String,

    /// The name of the entry shown in Wiki. Only use when `name` needs to be
    /// different from full name.
    #[serde(rename = "nameInWiki")]
    pub name_in_wiki: Option<String>,

    /// A string that is used as a placeholder text for an input field.
    pub input: Option<String>,

    /// The rule text. Markdown is available.
    pub rules: Option<String>,

    /// The range. Markdown is available. Applies to traits.
    pub range: Option<String>,

    /// Use if text cannot be generated by the app. Markdown is available.
    pub prerequisites: Option<String>,

    /// Prepends the provided string to the main prerequisites string. No
    /// effect if `prerequisites` field is used in l10n file. Markdown is
    /// available.
    #[serde(rename = "prerequisitesStart")]
    pub prerequisites_start: Option<String>,

    /// Appends the provided string to the main prerequisites string. No effect
    /// if `prerequisites` field is used in l10n table. Markdown is available.
    #[serde(rename = "prerequisitesEnd")]
    pub prerequisites_end: Option<String>,

    /// The AP value. Only use this if the text provides different information
    /// than `X adventure points`, e.g. for Special Ability Property Knowledge
    /// it is \"10 adventure points for the first *Property Knowledge*, 20
    /// adventure points for the second, 40 adventure points for the third\".
    /// Markdown is available.
    #[serde(rename = "apValue")]
    pub ap_value: Option<String>,

    /// An addition to the default AP value schema. Only use this if the text
    /// provides information appended to `X adventure points` and if `apValue`
    /// is not used. Markdown is available.
    #[serde(rename = "apValueAppend")]
    pub ap_value_append: Option<String>
}

impl Localization for TraitLocalization {
    fn name(&self) -> &str {
        &self.name
    }
}

/// The intrinsic trait of a character. This is used as a generic term for
/// advantages and disadvantages.
#[derive(Deserialize, Serialize)]
pub struct Trait {
    pub id: u32,
    pub levels: Option<u32>,
    pub max: Option<u32>,
    #[serde(rename = "selectOptions")]
    pub select_options: Option<SelectOptions>,
    pub group: TraitGroup,
    pub prerequisites: Option<TraitlListOrByLevelPrerequisite>,
    #[serde(rename = "apValue")]
    pub ap_value: Option<APValue>,

    /// Does this advantage/disadvantage not count towards the maximum of AP to
    /// be spent on advantages/disadvantages?
    #[serde(rename = "noMaxAPInfluence")]
    pub no_max_ap_influence: Option<bool>,

    /// Does this advantage/disadvantage exclusively applies to arcane
    /// spellworks but not to magical actions and applications?
    #[serde(rename = "isExclusiveToArcaneSpellworks")]
    pub is_exclusive_to_arcane_spellworks: Option<bool>,
    pub src: SourceRefs,
    pub translations: Translations<TraitLocalization>
}

#[derive(Serialize, Deserialize)]
pub struct Advantage {
    #[serde(flatten)]
    pub data: Trait
}

impl Identifiable for Advantage {
    fn id(&self) -> Id {
        Id::new(Category::Advantages,  self.data.id)
    }
}

impl Translatable<TraitLocalization> for Advantage {
    fn translations(&self) -> &Translations<TraitLocalization> {
        &self.data.translations
    }
}

#[derive(Serialize, Deserialize)]
pub struct Disadvantage {
    #[serde(flatten)]
    pub data: Trait
}

impl Identifiable for Disadvantage {
    fn id(&self) -> Id {
        Id::new(Category::Disadvantages, self.data.id)
    }
}

impl Translatable<TraitLocalization> for Disadvantage {
    fn translations(&self) -> &Translations<TraitLocalization> {
        &self.data.translations
    }
}
